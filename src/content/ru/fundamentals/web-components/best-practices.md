project_path: /web/fundamentals/_project.yaml
book_path: /web/fundamentals/_book.yaml
description: Кастомные элементы позволяют вам блабла Кастомные элементы позволяют вам блабла Кастомные элементы позволяют вам блабла Кастомные элементы позволяют вам блабла Кастомные элементы позволяют вам блабла

{# wf_updated_on: 2018-09-20 #} {# wf_published_on: 2017-08-14 #} {# wf_blink_components: Blink>DOM #}

# Рекомендации по использованию пользовательских элементов {: .page-title}

Пользовательские элементы позволяют расширять HTML и определять собственные теги. Они невероятно мощные функции, но они также низкоуровневые, что означает, что не всегда понятно, как лучше реализовать свой собственный элемент.

Чтобы помочь вам создать наилучший возможный опыт, мы составили этот контрольный список, в котором разбиты все вещи, которые, по нашему мнению, необходимы для того, чтобы стать хорошим элементом пользовательского элемента.

<style>
  @media screen and (min-width: 1001px) {
    table.ce-cl td:first-of-type { width: 175px; min-width: 175px; }
  }
</style>

## Контрольный список {: #checklist}

### Shadow DOM {: # shadow-dom}

<table class="responsive ce-cl"><tbody>
<tr><th colspan="2"><h3> Создайте теневой корень для инкапсуляции стилей. </h3></th></tr>
<tr>
<td> <b>Почему?</b> </td>
<td> Инкапсуляция стилей в теневом корне вашего элемента гарантирует, что он будет работать независимо от того, где он используется. Это особенно важно, если разработчик хочет разместить ваш элемент внутри теневого корня другого элемента. Это относится даже к простым элементам, таким как флажок или переключатель. Возможно, единственным контентом внутри вашего теневого корня будут сами стили. </td>
</tr>
<tr>
<td> <b>пример</b> </td>
<td> <howto-checkbox> элемент. </howto-checkbox>
</td>
</tr>
</tbody></table>
<table class="responsive ce-cl"><tbody>
<tr><th colspan="2"><h3> Создайте свой теневой корень в конструкторе. </h3></th></tr>
<tr>
<td> <b>Почему?</b> </td>
<td> Конструктор - это когда у вас есть <b>эксклюзивные знания</b> о вашем элементе. Это прекрасное время для настройки деталей реализации, с которыми вы не хотите, чтобы другие элементы возились. Выполнение этой работы в более позднем обратном вызове, таком как <code>connectedCallback</code> , означает, что вам нужно будет защититься от ситуаций, когда ваш элемент отсоединяется и затем присоединяется к документу. </td>
</tr>
<tr>
<td> <b>пример</b> </td>
<td> <howto-checkbox> элемент. </howto-checkbox>
</td>
</tr>
</tbody></table>
<table class="responsive ce-cl"><tbody>
<tr><th colspan="2"><h3> Поместите любые дочерние элементы, которые создает элемент, в его теневой корень. </h3></th></tr>
<tr>
<td> <b>Почему?</b> </td>
<td> Дочерние элементы, созданные вашим элементом, являются частью его реализации и должны быть частными. Без защиты теневого корня внешний JavaScript может случайно помешать этим детям. </td>
</tr>
<tr>
<td> <b>пример</b> </td>
<td> <howto-tabs> элемент. </howto-tabs>
</td>
</tr>
</tbody></table>
<table class="responsive ce-cl"><tbody>
<tr><th colspan="2"><h3> Установите стиль отображения <code>:host</code> (например, <code>block</code> , <code>inline-block</code> , <code>flex</code> ), если вы не предпочитаете <code>inline</code> по умолчанию. </h3></th></tr>
<tr>
<td> <b>Почему?</b> </td>
<td> Пользовательские элементы являются <code>display: inline</code> по умолчанию, поэтому установка их <code>width</code> или <code>height</code> будет иметь никакого эффекта. Это часто бывает неожиданностью для разработчиков и может вызвать проблемы, связанные с выкладкой страницы. Если вы не предпочитаете <code>inline</code> отображение, вы всегда должны устанавливать значение <code>display</code> умолчанию. </td>
</tr>
<tr>
<td> <b>пример</b> </td>
<td> <howto-checkbox> элемент. </howto-checkbox>
</td>
</tr>
</tbody></table>
<table class="responsive ce-cl"><tbody>
<tr><th colspan="2"><h3> Добавьте стиль отображения <code>:host</code> который учитывает скрытый атрибут. </h3></th></tr>
<tr>
<td> <b>Почему?</b> </td>
<td> Пользовательский элемент со стилем <code>display</code> умолчанию, например <code>:host { display: block }</code> , переопределит встроенный <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/hidden"><code>hidden</code> атрибут</a> более низкой специфичности. Это может вас удивить, если вы ожидаете установки атрибута <code>hidden</code> для вашего элемента, чтобы он <code>display: none</code> . В дополнение к стилю <code>display</code> умолчанию добавьте поддержку <code>hidden</code> с помощью <code>:host([hidden]) { display: none }</code> . </td>
</tr>
<tr>
<td> <b>пример</b> </td>
<td> <howto-checkbox> элемент.</howto-checkbox>
</td>
</tr>
</tbody></table> ### Атрибуты и свойства {: # attribute-properties} <table class="responsive ce-cl"><tbody>
<tr><th colspan="2"><h3> Не переопределяйте глобальные атрибуты, установленные автором. </h3></th></tr>
<tr>
<td> <b>Почему?</b> </td>
<td> Глобальные атрибуты - это те, которые присутствуют во всех элементах HTML. Некоторые примеры включают <code>tabindex</code> и <code>role</code> . Пользовательский элемент может <code>tabindex</code> установить его начальный <code>tabindex</code> 0, чтобы он мог фокусироваться на клавиатуре. Но вы всегда должны сначала проверять, установил ли разработчик, использующий ваш элемент, другое значение. Если, например, они установили <code>tabindex</code> на -1, это сигнал о том, что они не хотят, чтобы элемент был интерактивным. </td>
</tr>
<tr>
<td> <b>пример</b> </td>
<td> <howto-checkbox> элемент. Это дополнительно объясняется в <a href="#dont-override">разделе «Не перезаписывать автора страницы».</a> </howto-checkbox>
</td>
</tr>
</tbody></table>
<table class="responsive ce-cl"><tbody>
<tr><th colspan="2"><h3> Всегда принимайте примитивные данные (строки, числа, логические значения) в качестве атрибутов или свойств. </h3></th></tr>
<tr>
<td> <b>Почему?</b> </td>
<td> Пользовательские элементы, такие как их встроенные аналоги, должны быть настраиваемыми. Конфигурация может быть передана декларативно, через атрибуты или обязательно через свойства JavaScript. В идеале каждый атрибут также должен быть связан с соответствующим свойством. </td>
</tr>
<tr>
<td> <b>пример</b> </td>
<td> <howto-checkbox> элемент. </howto-checkbox>
</td>
</tr>
</tbody></table>
<table class="responsive ce-cl"><tbody>
<tr><th colspan="2"><h3> Стремитесь поддерживать примитивные атрибуты данных и свойства в синхронизации, отражая от свойства к атрибуту, и наоборот. </h3></th></tr>
<tr>
<td> <b>Почему?</b> </td>
<td> Вы никогда не знаете, как пользователь будет взаимодействовать с вашим элементом. Они могут установить свойство в JavaScript, а затем ожидать чтения этого значения с помощью API, такого как <code>getAttribute()</code> . Если у каждого атрибута есть соответствующее свойство, и оба они отражают, пользователям будет проще работать с вашим элементом. Другими словами, вызов <code>setAttribute('foo', value)</code> также должен установить соответствующее свойство <code>foo</code> и наоборот. Есть, конечно, исключения из этого правила. Вы не должны отражать высокочастотные свойства, например <code>currentTime</code> в видеоплеере. Используйте свое лучшее суждение. Если кажется, что пользователь будет взаимодействовать со свойством или атрибутом, и отражать его не обременительно, сделайте это. </td>
</tr>
<tr>
<td> <b>пример</b> </td>
<td> <howto-checkbox> элемент. Это дополнительно объясняется в <a href="#avoid-reentrancy">Избегать вопросов повторного входа</a> . </howto-checkbox>
</td>
</tr>
</tbody></table>
<table class="responsive ce-cl"><tbody>
<tr><th colspan="2"><h3> Стремитесь принимать только расширенные данные (объекты, массивы) в качестве свойств. </h3></th></tr>
<tr>
<td> <b>Почему?</b> </td>
<td> Вообще говоря, нет примеров встроенных элементов HTML, которые принимают расширенные данные (простые объекты JavaScript и массивы) через свои атрибуты. Вместо этого расширенные данные принимаются либо через вызовы методов, либо через свойства. Есть несколько очевидных недостатков при приеме расширенных данных в качестве атрибутов: сериализация большого объекта в строку может быть дорогой, и любые ссылки на объекты будут потеряны в процессе строковой классификации. Например, если вы структурируете объект, который имеет ссылку на другой объект, или, возможно, узел DOM, эти ссылки будут потеряны. </td>
</tr>
</tbody></table>
<table class="responsive ce-cl"><tbody>
<tr><th colspan="2"><h3> Не отражайте богатые свойства данных для атрибутов. </h3></th></tr>
<tr>
<td> <b>Почему?</b>/ Б> </td>
<td> Отражение богатых свойств данных в атрибутах является излишне дорогостоящим, требующим сериализации и десериализации одних и тех же объектов JavaScript. Если у вас нет варианта использования, который может быть решен только с помощью этой функции, вероятно, лучше избегать его. </td>
</tr>
</tbody></table>
<table class="responsive ce-cl"><tbody>
<tr><th colspan="2"><h3> Рассмотрите возможность проверки свойств, которые могли быть установлены до обновления элемента. </h3></th></tr>
<tr>
<td> <b>Почему?</b> </td>
<td> Разработчик, использующий ваш элемент, может попытаться установить свойство элемента до его определения. Это особенно верно, если разработчик использует платформу, которая обрабатывает загрузку компонентов, печать их на странице и привязку их свойств к модели. </td>
</tr>
<tr>
<td> <b>пример</b> </td>
<td> <howto-checkbox> элемент. Далее объясняется в <a href="#lazy-properties">разделе Сделать свойства ленивыми</a> . </howto-checkbox>
</td>
</tr>
</tbody></table>
<table class="responsive ce-cl"><tbody>
<tr><th colspan="2"><h3> Не самостоятельно применять классы. </h3></th></tr>
<tr>
<td> <b>Почему?</b> </td>
<td> Элементы, которые должны выражать свое состояние, должны делать это с помощью атрибутов. Атрибут <code>class</code> как правило, считается принадлежащим разработчику, использующему ваш элемент, и запись в него самостоятельно может случайно помешать классам разработчика. </td>
</tr>
</tbody></table> ### События <table class="responsive ce-cl"><tbody>
<tr><th colspan="2"><h3> Отправка событий в ответ на активность внутреннего компонента. </h3></th></tr>
<tr>
<td> <b>Почему?</b> </td>
<td> Ваш компонент может иметь свойства, которые изменяются в ответ на действия, о которых знает только ваш компонент, например, если таймер или анимация завершаются, или ресурс завершает загрузку. Полезно отправлять события в ответ на эти изменения, чтобы уведомить хост о том, что состояние компонента отличается. </td>
</tr>
</tbody></table>
<table class="responsive ce-cl">
<tbody>
<tr><th colspan="2"><h3> Не отправляйте события в ответ на настройку свойства хостом (нисходящий поток данных). </h3></th></tr>
<tr>
<td> <b>Почему?</b> </td>
<td> Отправка события в ответ на настройку свойства хостом является излишней (хост знает текущее состояние, потому что он просто установил его). Диспетчеризация событий в ответ на хост, устанавливающий свойство, может вызвать бесконечные циклы в системах привязки данных. </td>
</tr>
<tr>
<td> <b>пример</b> </td>
<td> <howto-checkbox> элемент.</howto-checkbox>
</td>     </tr>   </tbody> </table>

## Explainers {: #explainers}

### Не переопределяйте автора страницы {: # dont-override}

Возможно, что разработчик, использующий ваш элемент, может захотеть переопределить некоторые из его начального состояния. Например, изменение его `role` ARIA или фокусируемости с помощью `tabindex` . Проверьте, установлены ли эти и любые другие глобальные атрибуты, прежде чем применять свои собственные значения.

```js
connectedCallback() {
  if (!this.hasAttribute('role'))
    this.setAttribute('role', 'checkbox');
  if (!this.hasAttribute('tabindex'))
    this.setAttribute('tabindex', 0);
```

### Сделать свойства ленивыми {: # lazy-properties}

Разработчик может попытаться установить свойство для вашего элемента до его определения. Это особенно верно, если разработчик использует платформу, которая обрабатывает загрузку компонентов, вставку их на страницу и привязку их свойств к модели.

В следующем примере, Угловой является декларативно связывающей ее моделью `isChecked` свойства с флажком в `checked` имущество. Если определение для howto-checkbox было загружено с отложенной загрузкой, возможно, что Angular попытается установить свойство selected перед обновлением элемента.

```html
<howto-checkbox [checked]="defaults.isChecked"></howto-checkbox>
```

Пользовательский элемент должен обрабатывать этот сценарий, проверяя, установлены ли какие-либо свойства в его экземпляре. [`<howto-checkbox>`](/web/fundamentals/architecture/building-components/examples/howto-checkbox) демонстрирует этот шаблон, используя метод с именем `_upgradeProperty()` .

```js
connectedCallback() {
  ...
  this._upgradeProperty('checked');
}

_upgradeProperty(prop) {
  if (this.hasOwnProperty(prop)) {
    let value = this[prop];
    delete this[prop];
    this[prop] = value;
  }
}
```

`_upgradeProperty()` захватывает значение из экземпляра без обновления и удаляет свойство, чтобы оно не скрывало собственный установщик свойств пользовательского элемента. Таким образом, когда определение элемента наконец загружается, оно может сразу же отобразить правильное состояние.

### Избегайте вопросов повторного входа {: # избежать повторного входа}

Соблазнительно использовать `attributeChangedCallback()` чтобы отразить состояние для базового свойства, например:

```js
// When the [checked] attribute changes, set the checked property to match.
attributeChangedCallback(name, oldValue, newValue) {
  if (name === 'checked')
    this.checked = newValue;
}
```

Но это может создать бесконечный цикл, если установщик свойств также отражает атрибут.

```js
set checked(value) {
  const isChecked = Boolean(value);
  if (isChecked)
    // OOPS! This will cause an infinite loop because it triggers the
    // attributeChangedCallback() which then sets this property again.
    this.setAttribute('checked', '');
  else
    this.removeAttribute('checked');
}
```

Альтернатива состоит в том, чтобы позволить установщику свойства отражать атрибут, и заставить получателя определять его значение на основе атрибута.

```js
set checked(value) {
  const isChecked = Boolean(value);
  if (isChecked)
    this.setAttribute('checked', '');
  else
    this.removeAttribute('checked');
}

get checked() {
  return this.hasAttribute('checked');
}
```

В этом примере добавление или удаление атрибута также установит свойство.

Наконец, `attributeChangedCallback()` может использоваться для обработки побочных эффектов, таких как применение состояний ARIA.

```js
attributeChangedCallback(name, oldValue, newValue) {
  const hasValue = newValue !== null;
  switch (name) {
    case 'checked':
      // Note the attributeChangedCallback is only handling the *side effects*
      // of setting the attribute.
      this.setAttribute('aria-checked', hasValue);
      break;
    ...
  }
}
```

## Обратная связь {: #feedback}

{% include "web / _shared / полезно.html"%}
